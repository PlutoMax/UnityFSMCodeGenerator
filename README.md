# Unity FSM Code Generator
C# code generation tool for finite state machines in Unity that can also parse a declarative PlayMaker FSM. Also has a super boring name.

## Motivation

Coding a finite state machine by hand is tedious. And error prone. Usually we just get lazy and throw a bunch of if-then-else statements in a function and hope for the best.

There are great libraries for building an FSM in code (see <https://github.com/dotnet-state-machine/stateless>), but I still find the machine definitions hard to understand despite the syntactic sugar.

Thankfully there is a great visual FSM designer on the Unity asset store: [PlayMaker](https://www.assetstore.unity3d.com/en/#!/content/368).

Sure it's great, you can write custom actions and visually script gameplay -- cool, 100% worth the $65 trust me. But it doesn't help you at all when you absolutely and unequivocally need FSM logic in code (debuggability, performance, portability, better versioning support, etc etc). 

Wouldn't it be great if you could visually design this:

![A telephone FSM](https://github.com/justonia/UnityFSMCodeGenerator/raw/master/Docs/telephone_playmaker_fsm_v02.PNG)

And through some hand-wavy magic end up with this:

![C# code](https://github.com/justonia/UnityFSMCodeGenerator/raw/master/Docs/telephone_code_1_v02.png)

And not be forced by hand to write this:

![Tedious C# code](https://github.com/justonia/UnityFSMCodeGenerator/raw/master/Docs/telephone_code_2_v02.png)

Just to call your fancy well-architected code like this:

![Look ma', interfaces](https://github.com/justonia/UnityFSMCodeGenerator/raw/master/Docs/telephone_code_3_v02.png)

**Well now you can!**

## Gory Details

This library contains a collection of custom PlayMaker actions you can use to define a *declarative* FSM -- i.e. one that defines the logic of what you want do and when, but does not itself contain the "how". That sounds kind of pointless, but in practice it means you let the FSM deal with all the annoying if-then-else state management and you write the fun stuff.

The FSMs generated by this library are themselves completely stateless. You provide interface implementations and a place to store the state, call SendEvent in response to external stimuli and like boring magic your methods get called when they should.

Additionally there is no reflection used at runtime (only when parsing and building the FSM in the editor), so interface method calls are inlined and easy to debug in the generated code. Garbage is also not generated as the queued event system under the hood pools the allocated classes.

Once a C# FSM is generated from a PlayMaker FSM, you can copy and paste and share the C# FSM code as it has zero dependencies on PlayMaker (or even Unity). Additionally, if you hate yourself and are too cheap to spend $65 on PlayMaker, you can manually create the data model used by the code generator. I wouldn't recommend it though.

## Examples

The project contains an implementation of a simple telephone similar to the [phone call example in stateless](https://github.com/dotnet-state-machine/stateless/blob/dev/example/TelephoneCallExample/PhoneCall.cs). 

- `Examples/Telephone/TelephoneFSM.prefab` - Contains a `PlayMakerFSM` defining the states and transitions for the telephone and a `PlayMakerCodeGenerator` that takes care of compilation of the FSM.
- [`Examples/Telephone/TelephoneFSM.Generated.cs`](https://github.com/justonia/UnityFSMCodeGenerator/blob/master/UnityFSMCodeGenerator/Examples/Telephone/TelephoneFSM.Generated.cs) - The code generated by compiling the TelephoneFSM.prefab.
- [`Examples/Telephone/Telephone.cs`](https://github.com/justonia/UnityFSMCodeGenerator/blob/master/UnityFSMCodeGenerator/Examples/Telephone/Telephone.cs) - The business logic and core interfaces for controlling the telephone in the `TelephoneExample.unity` scene.

A primary takeaway (and my opinion) is that `Telephone.cs` contains zero if-then-else checks related to state, and is much easier to read than if the class contained all of the state checking explicitly. It's just the fun stuff.

**Note:** You will need your own copy of PlayMaker to be able to modify or view the visual FSM, but the example will work perfectly fine without it. 

## Status

Alpha, but functional.

Transitions, enter/exit callbacks, internal action callbacks, and code generation by introspection into a PlayMaker FSM all working.

Still needs much more documentation, unit tests, support for IgnoreEventAction, better error handling in the UI, potentially support for delegate arguments (maybe), and a bunch of other stuff.
